package com.forrest.util;import android.content.Context;import android.os.Environment;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import java.math.BigInteger;import java.security.MessageDigest;import java.text.SimpleDateFormat;import java.util.GregorianCalendar;import java.util.Locale;/** * Created by yuzh on 2017/2/22. * 文件操作相关的工具类 */public class FileUtil {    private final static String DIR_NAME = "USBCamera";    private final static String[] VIDEO_SET = {".mp4", ".MP4"};    private final static String[] IMG_SET = {".jpg", ".JPG"};    private static final SimpleDateFormat mDateTimeFormat = new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US);    /**     * generate output file     * @param type Environment.DIRECTORY_MOVIES / Environment.DIRECTORY_DCIM etc.     * @param ext .mp4(.m4a for audio) or .png     * @return return null when this app has no writing permission to external storage.     */    public static final File getCaptureFile(final String type, final String ext) {        final File dir = new File(Environment.getExternalStoragePublicDirectory(type), DIR_NAME);        dir.mkdirs();        if (dir.canWrite()) {            File dirs = new File(dir, getDateTimeString() + ext);            return dirs;        }        return null;    }    public static final File getPictureFile(final String type, final String ext) {        final File dir = new File(Environment.getExternalStoragePublicDirectory(type), DIR_NAME);        dir.mkdirs();        if (dir.canWrite()) {            File dirs = new File(dir, "IMG_" + getDateTimeString() + ext);            return dirs;        }        return null;    }    public static final File getVideoFile(final String type, final String ext) {        final File dir = new File(Environment.getExternalStoragePublicDirectory(type), DIR_NAME);        dir.mkdirs();        if (dir.canWrite()) {            File dirs = new File(dir, "VID_" + getDateTimeString() + ext);            return dirs;        }        return null;    }    public static final File getScreenCaptureFile(final String type, final String ext) {        final File dir = new File(Environment.getExternalStoragePublicDirectory(type), DIR_NAME);        dir.mkdirs();        if (dir.canWrite()) {            File dirs = new File(dir, "ScreenCapture_" + getDateTimeString() + ext);            return dirs;        }        return null;    }    public static final File getSelfieCaputureFile(final String type, final String ext) {        final File dir = new File(Environment.getExternalStoragePublicDirectory(type), DIR_NAME);        dir.mkdirs();        if (dir.canWrite()) {            File dirs = new File(dir, "SelfieCapture_" + getDateTimeString() + ext);            return dirs;        }        return null;    }    /**     * get current date and time as String     * @return     */    public static final String getDateTimeString() {        final GregorianCalendar now = new GregorianCalendar();        return mDateTimeFormat.format(now.getTime());    }    public static long getFileSize(String path) {        File file = new File(path);        if (file.exists() && file.isFile()) {            return file.length();        } else {            return -1;        }    }    /**     * 获取文件夹大小     * @param file File实例     * @return long     */    public static long getFolderSize(File file){        long size = 0;        try {            File[] fileList = file.listFiles();            for (int i = 0; i < fileList.length; i++) {                if (fileList[i].isDirectory()) {                    size = size + getFolderSize(fileList[i]);                } else {                    size = size + fileList[i].length();                }            }        } catch (Exception e) {            e.printStackTrace();        }        return size;    }    /**     * 修改文件夹名称     * @param src 旧文件夹路径     * @param dest 新文件夹路径     * @return     */    private boolean renameToNewFile(String src, String dest) {        File srcDir = new File(src);  //旧文件夹路径        boolean isOk = srcDir.renameTo(new File(dest));  //dest新文件夹路径，通过renameto修改        System.out.println("renameToNewFile is OK ? :" +isOk);        return isOk;    }    /**     * 复制单个文件     * @param oldPath String 原文件路径 如：c:/fqf.txt     * @param newPath String 复制后路径 如：f:/fqf.txt     * @return boolean     */    public static void copyFile(String oldPath, String newPath) {        try {            int bytesum = 0;            int byteread = 0;            File oldfile = new File(oldPath);            File newfile = new File(newPath);            if (newfile.exists()) {                deleteFile(newfile);            }            if (oldfile.exists()) { //文件存在时                InputStream inStream = new FileInputStream(oldPath); //读入原文件                FileOutputStream fs = new FileOutputStream(newPath);                byte[] buffer = new byte[1024*1024];                while ( (byteread = inStream.read(buffer)) != -1) {                    bytesum += byteread; //字节数 文件大小                    fs.write(buffer, 0, byteread);                }                inStream.close();            }        } catch (Exception e) {            System.out.println("复制单个文件操作出错");            e.printStackTrace();        }    }    /**     * 修改文件名     * @param oldpath     * @param newpath     * @throws IOException     */    public static void newFile(String oldpath, String newpath) throws IOException {        File file = new File(oldpath);        file.renameTo(new File(newpath));    }    /**     * 删除文件安全方式：     * @param file     */    public static void deleteFile(File file) {        if (file.isFile()) {            deleteFileSafely(file);            return;        }        if (file.isDirectory()) {            File[] childFiles = file.listFiles();            if (childFiles == null || childFiles.length == 0) {                deleteFileSafely(file);                return;            }            for (int i = 0; i < childFiles.length; i++) {                deleteFile(childFiles[i]);            }            deleteFileSafely(file);        }    }    /**     * 安全删除文件.     * @param file     * @return     */    public static boolean deleteFileSafely(File file) {        if (file != null) {            String tmpPath = file.getParent() + File.separator + System.currentTimeMillis();            File tmp = new File(tmpPath);            file.renameTo(tmp);            return tmp.delete();        }        return false;    }    public static void appendToFile(String outputPath, byte[] data, int length) {        RandomAccessFile randomFile = null;        try {            randomFile = new RandomAccessFile(outputPath, "rw");            long fileLength = randomFile.length();            randomFile.seek(fileLength);            randomFile.write(data, 0, length);        } catch (IOException e) {            e.printStackTrace();        } finally {            if (randomFile != null) {                try {                    randomFile.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    /**     * 将数据插入文件     * @param file     * @param pos     * @param data     * @param dataLen     */    public static void insertDataToFile(File file, long pos, byte[] data, int dataLen) {        RandomAccessFile raf = null;        try {            File tmp = File.createTempFile("tmp", null);            FileOutputStream fos = new FileOutputStream(tmp);            FileInputStream fis = new FileInputStream(tmp);            raf = new RandomAccessFile(file, "rw");            raf.seek(pos);            byte[] buf = new byte[2048];            int readn;            while ((readn = raf.read(buf)) > 0) {                fos.write(buf, 0, readn);            }            raf.seek(pos);            raf.write(data,0, dataLen);            while ((readn = fis.read(buf)) > 0) {                raf.write(buf, 0, readn);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                raf.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    /**     * 修改文件内容     * @param file 需要修改的文件     * @param pos 需要修改的位置     * @param oldDataLen 需要修改文件的长度     * @param newData 要写入的文件数据内容     * @param newDataLen 要写入文件的数据长度     */    public static void modifyDataToFile(File file, long pos, int oldDataLen, byte[] newData, int newDataLen) {        RandomAccessFile raf = null;        try {            File tmp = File.createTempFile("tmp", null);            FileOutputStream fos = new FileOutputStream(tmp);            FileInputStream fis = new FileInputStream(tmp);            raf = new RandomAccessFile(file, "rw");            raf.seek(pos + oldDataLen);            byte[] buf = new byte[2048];            int readn;            while ((readn = raf.read(buf)) > 0) {                fos.write(buf, 0, readn);            }            raf.seek(pos);            raf.write(newData,0, newDataLen);            while ((readn = fis.read(buf)) > 0) {                raf.write(buf, 0, readn);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            try {                raf.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    public static String writeToCacheFile(Context context, String fileName, String content) {        File file = new File(context.getCacheDir(), fileName);        String fileAbsolutePath = file.getAbsolutePath();        try {            FileOutputStream fos = new FileOutputStream(file);            fos.write(content.getBytes());            fos.close();        } catch (IOException e) {            e.printStackTrace();        }        return fileAbsolutePath;    }    public static String writeToCacheFile(Context context, String fileName, byte[] content) {        File file = new File(context.getCacheDir(), fileName);        String fileAbsolutePath = file.getAbsolutePath();        try {            FileOutputStream fos = new FileOutputStream(file);            fos.write(content);            fos.close();        } catch (IOException e) {            e.printStackTrace();        }        return fileAbsolutePath;    }    public static String writeToFile(String dir, String fileName, byte[] content) {        File fileDir = new File(dir);        if(!fileDir.exists()) {            fileDir.mkdir();        }        File file = new File(dir, fileName);        String fileAbsolutePath = file.getAbsolutePath();        try {            FileOutputStream fos = new FileOutputStream(file);            fos.write(content);            fos.close();        } catch (IOException e) {            e.printStackTrace();        }        return fileAbsolutePath;    }    /**     * 获取单个文件的MD5值！     * @param file     * @return     */    public static String getFileMD5(File file) {        if (!file.isFile()) {            return null;        }        MessageDigest digest = null;        FileInputStream in = null;        byte buffer[] = new byte[1024];        int len;        try {            digest = MessageDigest.getInstance("MD5");            in = new FileInputStream(file);            while ((len = in.read(buffer, 0, 1024)) != -1) {                digest.update(buffer, 0, len);            }            in.close();        } catch (Exception e) {            e.printStackTrace();            return null;        }        BigInteger bigInt = new BigInteger(1, digest.digest());        return bigInt.toString(16);    }    //过滤文件, 选在符合formatSet格式的文件    private static boolean filterFile(String path, String[] formatSet) {        for (String f : formatSet){            if (path.endsWith(f)){                return true;            }        }        return false;    }    //判断是否是视频文件 根据后缀名    private static boolean isVideoType(String path) {        for (String f : VIDEO_SET){            if (path.endsWith(f)) {                return true;            }        }        return false;    }    //判断文件是否为图片 根据后缀名    private static boolean isImageType(String path) {        for (String f : IMG_SET){            if (path.endsWith(f)) {                return true;            }        }        return false;    }}